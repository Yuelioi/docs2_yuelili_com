# optransform 做一个运动控制风格的相机

下载场景：文件：moco_example_scene.hip

Gary Jaeger 在 Sidefx 列表中提出的问题，这是我多年来一直在脑海中思考的问题，终于有机会尝试一下了。

我们有一个飞行的立方体和一个静止的相机，我们想要反转它，即有一个静止的立方体和一个飞行的相机。回想一下星球大战的经典动作控制镜头，宇宙飞船模型大部分是静止的，摄像机会围绕它们进行变焦，使它们看起来像是在飞行。

如果这是 2 个几何体，这很容易；从一个矩阵中读取矩阵，将其反转，然后应用到另一个矩阵中。不幸的是，因为我们有一个摄像头，而摄像头不能在 vex 中操作，我们必须找到另一种方法。

相反，我们可以使用铆钉。在最简单的形式中，它就像一个单点的复制 sop；给它一个点的路径，然后你可以将对象作为铆钉的父对象，它们会坚持到这一点。因此，我制作了一个具有单个点的地理对象，并在Vex中读取动画立方体变换，反转运动，将其应用于该点：

```cpp
matrix m = optransform('/obj/moving_cube');
@P *= invert(m);
```

但是旋转呢？查看铆钉参数，它支持旋转，但只能通过@N 和@up。在这一点上，我意识到我知道如何从@N 和@up 到矩阵或四元数，但不是其他方式。在上面睡觉之后，意识到它比我预期的要容易，并将其添加到我的Vex中：

```cpp
matrix m = optransform('/obj/moving_cube');
@P *= invert(m);

matrix3 m_rot = matrix3(m);
@N = {0,0,1}*invert(m_rot);
@up = {1,0,0}* invert(m_rot);
```

使用@N和@up进行旋转时，@N指向z轴，@up指向y轴。因此，要从矩阵重新创建@N 和@up，只需取 z 向量 {0,0,1} 并将其乘以矩阵，并对 y 向量 {0,1,0} 执行相同的操作。

起初这对我不起作用，在再次睡觉后（是的我很困）我意识到这是因为我使用的是完整的 4x4（旋转+位置+剪切）而不是正确的 3x3（只是旋转） . 显式转换为 3x3 矩阵修复了它。

从理论上讲，您还可以使用 cracktransform() 来获取欧拉旋转值，并使用 hscript 将它们插入相机，但我发现我现在越来越积极地避免使用 hscript。这对我来说似乎更干净。也就是说，我敢肯定有人会有比这更干净的解决方案......
