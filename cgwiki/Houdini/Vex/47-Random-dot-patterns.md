# 随机点图案

圆点滑块.gif
最终目标。这么多点！

点 vop 很好，但有点受限，有人不和谐地问如何扩展它。

我有一种预感，我可以查看一些 shadertoy 代码，并将其移植到 vex。当我完成一个超级基本的设置时，Jake Rice 已经制作了一个全能载歌载舞的版本。呵呵。

尽管如此，还是很高兴将其拉回第一原则，认为它会成为一个很好的迷你教程。

制作一个具有 500x500 点的网格，对其进行 uvtexture（在点模式下使用 uv），附加一个Vex。

首先，让我们可视化这些 uv：

圆点01.PNG

如果我们想要 10x10 点，让我们乘以 10：

圆点02.PNG

我们可以使用frac函数去除小数点前的任何内容，因此 {8.25,4.12} 的 uv 变为 {0.25, 0.12}。这具有将我们的 uv 平铺到迷你 10x10 区域的效果：

圆点03.PNG

这些迷你区域中的每一个在 uv 空间中从 0 到 1。我们可以测量 uvs 的长度，这应该会给我们一些圆形渐变：

圆点04.PNG

好吧，有点。我们得到了四分之一的渐变，因为每个图块的 {0,0} 都在角落里。如果我们可以将它移动到每个图块的中心，我们就会得到一个干净的圆形渐变。

图块的中心位于 {0.5,0.5}。要移动这些 uv，使中心变成 0 值，我们乘以 2，然后减去 1。

圆点05.PNG

现在，如果我们将它与 length() 一起使用，我们应该会得到漂亮的圆形渐变：

圆点06.PNG

嗯？有点正确，但这些值看起来很奇怪......哦等一下，在计算长度之前看看geo电子表格中发生了什么：

圆点07.PNG

即使我们知道 uv 只是 2 个值，即 u 和 v，houdini 总是将它存储为一个 3 值向量，并且只将最后一个分量保留为零。当我们将其复制到颜色并运行上面的公式时，我们仍在计算蓝色通道。它减去 1，所以所有点的蓝色都是 -1。-1 的长度是 1，这是破坏性的东西。在计算长度之前，我们必须确保蓝色值为 0。有很多方法可以做到这一点，我选择更正确并使用向量进行计算而不是惰性浮点数：

圆点08.PNG

在视口中看起来相同，但geo电子表格中的蓝色列现在为 0。计算长度现在看起来是正确的：

圆点09.PNG

现在如何将此渐变转换为点？我们可以fit()这个，所以我们说 0.5 到 0.6 之间的值将变成 0 到 1 之间的值，这个范围之外的值将被限制：

圆点10.PNG

smooth() 函数与 fit01() 基本相同，它们只是假设输出需要介于 0 和 1 之间。Smooth 具有偏差函数的额外优势，您可以使用它来调整形状渐变边缘应该你想要它。它与 HLSL/GLSL 中的 smoothstep() 函数非常相似，它可以使移植您在 shadertoy 上看到的东西更容易一些。:)

圆点11.PNG

好的，那是普通的点。我们如何给它们随机偏移量？回到我们做的 frac() ，如果 frac 保留小数点后的值，floor()则相反，保留小数点前的值，例如 {7.25, 3.23} 变为 {7,3}。

圆点12.PNG

现在我们每个图块都有一个“洪水填充”值，我们可以将其提供给 rand()，以获得每个图块的兰特值：

圆点13.PNG

我们可以将其视为一个向量，并将其添加到之前的中心偏移 uv：

圆点14.PNG

啊，有点蓝，别再掉进那个陷阱了。确保删除任何蓝色：

圆点15.PNG

现在计算长度并平滑它，我们的点看起来如何？

圆点16.PNG

它们是偏移的，但偏移太多并且正在剪掉它们的瓷砖边缘。这些点在它们的图块中非常大，所以我们应该缩小它们以给它们更多的偏移空间。此外，偏移值过于极端且为正，因此让它们以零为中心并通过拟合减小它们的范围。与往常一样，必须确保第三个组件归零，我在这里使用了不同的策略并明确设置它：

圆点17a.PNG

最后我们可以换掉频道滑块的幻数，得到一些不错的互动：

圆点滑块.gif

这是完整的代码：

```cpp
int tiles = chi('tiles');
float rand = ch('rand');
float start = ch('dotradius_start');
float end = ch('dotradius_end');
vector offset = rand(floor(@uv*tiles)) * {1,1,0};
offset = fit(offset,0,1,-rand,rand); 
offset.z = 0;
@Cd = smooth(start, end , length(frac(@uv*tiles)*{2,2,0}-{1,1,0}+offset));
```

如果您想更进一步，可以尝试以下练习：

你能做随机大小的点吗？
你能给他们随机的颜色吗？
您可以使用 for 循环来获得重叠的点层吗？
