# 示例：波浪变形器

一个经典案例。准备好 40x40 网格了吗？

我们将制作从中心辐射的同心正弦波。这意味着我们需要测量每个点到原点的距离：

```cpp
@d = length(@P);
```

将其提供给 sin()，并使用它直接设置每个点的 y 位置：

```cpp
@P.y = sin(@d);
```

很好，但是波浪对于默认网格来说太大了。让@d 乘以某个因子，这会给获得更多的波浪。把上一行代码更改为：

```cpp
@P.y = sin(@d*4);
```

好，接着让它由滑块驱动：

```cpp
@P.y = sin(@d*ch('scale'));
```

按下按钮，使用滑块（您可以将滑块推到 1），观察波浪移动。

要使波浪具有动画效果，请向内项添加时间。

```cpp
@P.y = sin(@d*ch('scale')+@Time);
```

等等，他们正在向内移动而不是向外。来把它变成负时间：

```cpp
@P.y = sin(@d*ch('scale')-@Time);
```

或者更好的是，通过滑块控制它，更方便：

```cpp
@P.y = sin(@d*ch('scale')+(ch('speed')*@Time));
```

太乱了，来我们整理一下吧。wrangles 的好处是你可以拆分多行以提高可读性：

```cpp
@d = length(@P);
@d *= ch('scale');
@speed = @Time*ch('speed');
@P.y = sin(@d+@speed);
```

再添加 2 个东西，一个最大高度的控件，一个基于距离的衰减。

高度很简单，无论最终结果是什么，将它乘以通道；如果 1 将保持不变，0 将取消，其他数字将适当缩放：

```cpp
@P.y *= ch('height');
```

最后控制衰减的斜坡。斜坡小部件需要 0-1 范围内的变量，因此要先获取距离变量，并使用 fit() 将其映射到 1 和 0 之间（注意我们是 1 0，而不是 0 1；希望中心具有最大高度）。起点和终点将由通道控制：

```cpp
@falloff = fit(@d, ch('start') , ch('end') , 1,0);
```

斜坡通道需要一个名称和一个变量，该变量将通过斜坡曲线重新映射。将获取结果并将其直接与 P.y 相乘：

```cpp
@P.y *= chramp('falloff', @falloff);
```

这里的一个小Vex是，我希望开始和结束以世界空间单位为单位，但“结束”通道是一个很大的数字。那是因为我们已经将 d 乘以缩放通道来控制波数。快速改代码修复了，这是最终结果：

```cpp
@d = length(@P);
@speed = @Time * ch('speed');
@falloff = fit(@d, ch('start'), ch('end'),1,0);

@P.y = sin(@d*ch('scale')+@speed);
@P.y *= ch('height');
@P.y *= chramp('falloff', @falloff);
```
